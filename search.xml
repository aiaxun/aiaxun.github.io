<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[ipython安装遇到的一个小问题]]></title>
      <url>%2F2017%2F04%2F11%2Fipython%E5%AE%89%E8%A3%85%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[问题描述在ubuntu kylin 14.04 系统上使用 sudo apt-get install ipython 命令安装了ipython。在终端打开时，遇到了 ImportError: No module named packaging.version 这样的问题。 解决方法在查找解决方案时，在Stackoverflow上的答案：importerror-no-module-named-packaging-version于是就去使用pip安装setuptools sudo pip install setuptools 但安装过程中遇到报错： /usr/local/lib/python2.7/dist-packages/pip/vendor/requests/packages/urllib3/util/ssl.py:122: InsecurePlatformWarning: A true SSLContext object is not available. This prevents urllib3 from configuring SSL appropriately and may cause certain SSL connections to fail. You can upgrade to a newer version of Python to solve this. For more information, see https://urllib3.readthedocs.io/en/latest/security.html#insecureplatformwarning. InsecurePlatformWarning 这里是讲系统中缺少了SSLContext想关的依赖库。查看了一篇blog pip安装模块警告InsecurePlatformWarning: A true SSLContext object is not available. 还有一个github上的讨论：InsecurePlatformWarning: A true SSLContext object is not available安装上了缺乏的依赖，终于把问题解决掉了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[知识图谱]]></title>
      <url>%2F2017%2F04%2F05%2F%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%2F</url>
      <content type="text"><![CDATA[知识图谱学习导航北京知识图谱学习小组]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Spring boot入门与使用]]></title>
      <url>%2F2017%2F03%2F30%2FSpring-boot%E5%85%A5%E9%97%A8%E4%B8%8E%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[源起工作中要部署一套比较高效、稳定的Web API服务，实现用户的登录授权、信息查询等功能。经过考虑，采用了当前流行的Spring boot框架。Spring boot优化了Spring框架的配置，使用起来风格有些类似于python Flask的风格，URL配置比较方便。 Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Boot致力于在蓬勃发展的快速应用开发领域（rapid application development）成为领导者。 我的入门博客： 扑耶博客 。其中的博文： 【教她写代码】使用Intellij创建第一个Springboot程序系列 Spring boot系列教程导航，写得非常浅显易懂，细节讲解详细，简单看看就能够快速入门看到效果。 看名字应该是博主给女友写的教程，点个赞！ PS: 搜索题目，百度索引到的结果竟然是CSDN转载的。。。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[解决了Hexo next主题leanCloud配置的一个坑]]></title>
      <url>%2F2017%2F03%2F29%2F%E8%A7%A3%E5%86%B3%E4%BA%86Hexo-next%E4%B8%BB%E9%A2%98leanCloud%E9%85%8D%E7%BD%AE%E7%9A%84%E4%B8%80%E4%B8%AA%E5%9D%91%2F</url>
      <content type="text"><![CDATA[问题： Next主题按照官网配置了leanCloud阅读次数统计之后不显示统计次数。详情： 在浏览器console会报错，找不到Counter 对象。发生的原因： leanCloud应用申请之后，没有创建Counter对象。解决方法： 去leanCloud控制台新建一个Counter对象即可，允许创建者读写。PS： 完成后最好使用hexo重新编译部署一下。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Linux page 保护机制]]></title>
      <url>%2F2017%2F03%2F29%2FLinux-page-%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6%2F</url>
      <content type="text"><![CDATA[Linux页表保护对 page 的保护措施有： ● 访问权限（User/Supervisor）: 缺省是无权限0，表示只能Super访问。 ● 读写权限（Read/Write）: 缺省是无权限0，表示只可读取。 ● 缺页保护（Present） ● 执行权限（No Execute）: 缺省是有权限1，表示可执行(只有64位和PAE模式下才有该标志) 当违反了这些保护措施时，processor 将会产生 #PF（page fault）异常。 保护措施 标志位 作用域 访问权限 U/S page 读写权限 R/W page 执行权限 NX page 缺页保护 P table 和 page 上表的 作用域 是保护措施的对象，对于缺页保护来说，它也作用于 table（各级 Page Translate Tables）注意：这里的 page 包括了 4K/2M/1G page 以及 4M page 访问权限（User/Supervisor）在PTE的 Bit2 位里就是 U/S 权限位： ● U/S = 0：仅供 Supervisor 访问 ● U/S = 1：User 和 Supervisor 都可以访问这里的 Supervisor 是指：具有 0 - 2 level 权限 的访问者，而 User 仅仅是 3 Level 权限的访问者。 #define _PAGE_BIT_USER#define _PAGE_USER (_AT(pteval_t, 1) &lt;&lt; _PAGE_BIT_USER) _PAGE_USER：表示开启User权限 读写权限（Read/Write）在读写权限方面同样是体现了最严格控制思想，x86/x64 体系对访问者（User/Supervisor）进行分别控制。在PTE的 Bit1 位里就是 R/W 权限位： ● R/W = 0：only read 权限 ● R/W = 1：read/write 权限 #define _PAGE_BIT_RW 1#define _PAGE_RW (_AT(pteval_t, 1) &lt;&lt; _PAGE_BIT_RW) _PAGE_RW:表示开启写权限，即可读可写 缺页保护（Present）在缺面保护里情形和上面 3 个保护措施有些不同：P 标志位不但影响最终的物理页面，也影响到各级的转换表在PTE的 Bit0 P 标志位，它由系统软件进行设置，意义是： ● P = 0：不存在物理内存中 ● P = 1：已提交到物理内存中12#define _PAGE_BIT_PRESENT 0 #define _PAGE_PRESENT (_AT(pteval_t, 1) &lt;&lt;_PAGE_BIT_PRESENT) _PAGE_PRESENT：表示该页存在于物理内存中。上述的保护措施在x86和x86_64上都是具有的，而在PAE模式和x86_64模式下增加了执行权限。 执行权限（No Execute）在 PAE或者x86_64 模式下在 table entry 结构里增加了 Bit63 - NX（No Execute）权限位，用来控制 page 是否有执行权限：执行权限缺省情况下是打开的，也就是缺省情况下 page 是可执行的，因此： NX = 0：可执行 NX = 1：不可执行 123456#define _PAGE_BIT_NX 63 #if defined(CONFIG_X86_64) || defined(CONFIG_X86_PAE) #define _PAGE_NX (_AT(pteval_t, 1) &lt;&lt; _PAGE_BIT_NX) #else #define _PAGE_NX (_AT(pteval_t, 0)) #endif _PAGE_NX：表示为No execute权限，从上面可以看出只有在X86_64和X86_PAE模式下有效，而在X86 模式下这已设置是无效的，等价于上面的Present位设置为0。 例子1：vmalloc与module_allocVmalloc: 实现的pgprot_t prot 为PAGE_KERNEL 12345678static inline void *__vmalloc_node_flags(unsigned long size, int node, gfp_t flags)&#123; return __vmalloc_node(size, 1, flags, PAGE_KERNEL, node, __builtin_return_address(0));&#125;#define __PAGE_KERNEL_EXEC \ (_PAGE_PRESENT | _PAGE_RW | _PAGE_DIRTY | _PAGE_ACCESSED | _PAGE_GLOBAL)#define __PAGE_KERNEL (__PAGE_KERNEL_EXEC | _PAGE_NX) 这里__PAGE_KERNEL：表明读写，super，在内存里面，没有执行权限。 例子2: Module_alloc: 实现的pgprot_t prot 为PAGE_KERNEL_EXEC,12345void *module_alloc(unsigned long size)&#123; return __vmalloc_node_range(size, 1, MODULES_VADDR, MODULES_END, GFP_KERNEL | __GFP_HIGHMEM, PAGE_KERNEL_EXEC, -1, __builtin_return_address(0));&#125; 测试利用即时编译技术思想，利用上述2中方法分配一段内存空间，直接将代码emit到内存空间中形成一个image函数，然后运行。 static inline u8 *emit_code(u8 *ptr, u32 bytes, unsigned int len) { if (len == 1) *ptr = bytes; else if (len == 2) *(u16 *)ptr = bytes; else { *(u32 *)ptr = bytes; barrier(); } return ptr + len; } #define EMIT(bytes, len) do { prog = emit_code(prog, bytes, len); } while (0) #define EMIT1(b1) EMIT(b1, 1) #define EMIT2(b1, b2) EMIT((b1) + ((b2) &lt;&lt; 8), 2) #define EMIT3(b1, b2, b3) EMIT((b1) + ((b2) &lt;&lt; 8) + ((b3) &lt;&lt; 16), 3) #define EMIT4(b1, b2, b3, b4) EMIT((b1) + ((b2) &lt;&lt; 8) + ((b3) &lt;&lt; 16) + ((b4) &lt;&lt; 24), 4) struct _handle { unsigned int (*bpf_func)(); }; static struct _handle handle; static int get_image() { u8* image = NULL; u8 temp[64]; u8* prog; unsigned char proglen = 6; prog = temp; EMIT1(0xb8); EMIT4(0x15,00,00,00); //movl $20, %eax EMIT1(0xc3); //ret //image = module_alloc(max_t(unsigned int,proglen,sizeof(struct work_struct))); image = vmalloc(proglen);//, GFP_KERNEL); if (!image) return -1; memcpy(image, temp, proglen); handle.bpf_func = (void *)image; return 0; } static int main_init(void) { int ret = 0; ret = get_image(); printk(&quot;get_image() ret:%d\n&quot;, ret); if(!ret) { ret = handle.bpf_func(); printk(&quot; handle.bpf_func() ret:%d\n&quot;,ret); } return 0; } 我们在x86模式下vmalloc和module_alloc方式都没问题，都没有违背page的保护原则，但是在x86_64下面vmalloc导致系统crash，由于它去掉了可执行权限，不能执行该image，违背了执行保护原则，而module_alloc能正常执行。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[配置文件使用]]></title>
      <url>%2F2017%2F03%2F29%2F%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[常见的配置文件格式properties文件格式为： *=* 的形式，如 server.port = 80server.address = 127.0.0.1 通常以前缀作为区分，在Java程序中经常用到。 ini文件ini文件是windows上常用的配置文件，格式为： [server]address = 127.0.0.1port = 80 或者使用 “:” 作为分割符，如： [server]address: 127.0.0.1port: 80 xml文件xml文件现在已经没有那么流行了，可读性差、解析困难。但格式比较规整。一些Java框架或者组件可能会使用XML来配置。比如Springboot的配置： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;&lt;/dependency&gt; json文件Json格式天然被前端JavaScript支持，成为一种非常流行的Server和Client交互的数据传输格式。格式大致如下，可以被解析成List、dict等多种元素。 12345[ &#123; key&quot;: value &#125;,] YAML近年来新开始流行的配置文件格式，读起来比较易懂。但还没有用过。示例： 123456789languages: - Ruby - Perl - Python websites: YAML: yaml.org Ruby: ruby-lang.org Python: python.org Perl: use.perl.org 引用自 阮一峰的网络日志 总结其实各种配置文件主要是为了能够多次复用、方便修改，格式可以自己规定，在配置项比较复杂的时候，优秀的配置文件能够提高效率，节省工程量。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[安全分析博客收藏]]></title>
      <url>%2F2017%2F03%2F28%2F%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90%E5%8D%9A%E5%AE%A2%E6%94%B6%E8%97%8F%2F</url>
      <content type="text"><![CDATA[离别歌在逛github的时候发现的安全大牛博客，后来在知乎上又看到了有人推荐该博客。该博客中分享了很多安全分析的技巧，所谓授之以渔不如授之以渔，这个博客很给力！链接离别歌]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[本博客的创建目的]]></title>
      <url>%2F2017%2F03%2F28%2F%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%2F</url>
      <content type="text"><![CDATA[一直以来的一个想法 在平常的学习工作中，总会碰到各种各样的问题，通过Google或者Baidu这样的搜索引擎来解决。但实际上，有很多问题在解决一次之后再次遇到，还是需要借助搜索引擎的力量找到原来的解决方法。原谅我这种懒人不太喜欢做学习笔记…另外，浏览器的书签也越来越多，使得我在每次找到对应的书签时都要耗费老大的力气，已经非常难以忍受这种方式了。于是就有了这个博客。本博客搭建的终极目标，就是让自己养成一个能够随时做笔记的习惯。规划的主要内容有： 工作中遇到的问题。记录的形式为抛出问题加上每篇找到的答案的摘要。 平常在网上随意浏览得到的知识。平时也喜欢关注各种各样的知识，包括流行的技术、报告、分析等。 逛一次就感觉不错的网站，为了防止忘记，把它记录在这里。好啦，简介到这里就结束啦。在这里，感谢github，hexo以及next 主题，为我提供了这个平台！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017%2F03%2F28%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
